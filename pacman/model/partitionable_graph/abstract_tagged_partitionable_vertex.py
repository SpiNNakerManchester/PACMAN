from pacman.model.partitioned_graph.taggable_partitioned_vertex import \
    TaggablePartitionedVertex
from pacman.model.partitionable_graph.abstract_partitionable_vertex \
    import AbstractPartitionableVertex
from pacman.model.constraints.abstract_constraints.\
     abstract_tag_allocator_constraint import AbstractTagAllocatorConstraint
from spynnaker.pyNN import exceptions

from abc import ABCMeta
from abc import abstractmethod
import logging


logger = logging.getLogger(__name__)

class AbstractTaggedPartitionableVertex(AbstractPartitionableVertex):
    """ The abstract tagged partitionable vertex is a type of vertex that is
        recognised when the partitioned vertex type has tags. Due to this, it
        is recommended that front end developers inherit from this class when
        creating neural models that need tags.

    """

    def __init__(self, n_atoms, label, max_atoms_per_core, tags, constraints=None):
        """ Constructor for the abstract tagged partitionable vertex.

        :param n_atoms: the number of atoms for the vertex
        :param label: the label of the vertex
        :param max_atoms_per_core: the max atoms that can be supported by a \
                    core. Note that this is translated into a partitioner max \
                    size constraint
        :param tags: a list of tag pairs (of some subtype of AbstractTag)
        :param constraints: any extra constraints to be added to this vertex.
        :type n_atoms: int
        :type label: str
        :type max_atoms_per_core: int
        :type tags: list
        :type constraints: iterable list

        :return: the new partitionable vertex object

        :rtype: \
                    :py:class:`pacman.model.partitionable_graph.abstract_tagged_partitionable_vertex.AbstractTaggedPartitionableVertex`

        :raise None: this method does not raise any exceptions
        """
        AbstractPartitionableVertex.__init__(self, n_atoms, label, 
                                             max_atoms_per_core, constraints)
        
        self._tags = [tag for tag in tags] # make sure to create a fresh list
        for tag in self._tags:
            self.add_tag_constraint(tag)
           
    def add_tag_constraint(self, tag):
        """ Add the necessary tag constraints to indicate that the vertex
            requires tags. Should be overridden in derived classes. The
            derived class needs to route its constraint generation through
            such a function because given the order of construction there
            is no other way to make sure only one constraint is instantiated
            for the vertex unless this abstract class didn't itself set up
            the constraint if required, which is fundamental to the class'
            functionality.
        """
        self.add_constraint(AbstractTagAllocatorConstraint(tag.board_address, 
                            tag.port, tag.tag))

    def create_subvertex(self, vertex_slice, resources_required, label=None,
                         constraints=None):
        """ Create a subvertex of this vertex.  Overrides the method in\
            AbstractPartitionableVertex.\

        :param label: The label to give the subvertex.  If not given, and the\
                    vertex has no label, no label will be given to the\
                    subvertex.  If not given and the vertex has a label, a\
                    default label will be given to the subvertex
        :type label: str
        :param vertex_slice: the slice of the partitionable vertex that this\
                    partitioned vertex will cover
        :type vertex_slice: pacman.model.graph_mapper.vertex_slice.VertexSlice
        :param constraints: An iterable of constraints for the subvertex.\
                    These are generated by the partitioner from the vertex\
                    constraints.
        :type constraints: iterable of\
                    :py:class:`pacman.model.constraints.abstract_constraint.AbstractConstraint`
        :raise pacman.exceptions.PacmanInvalidParameterException:
                    * If lo_atom or hi_atom are out of range
                    * If one of the constraints is invalid
        """          
        return TaggablePartitionedVertex(label=label,
                                 resources_required=resources_required,
                                 constraints=constraints)

    @property
    def tags(self):
        """ The tags assigned to this vertex

        :return: A tuple of the tags
        :rtype: tuple
        :raise None: Raises no known exceptions
        """
        # build a tuple to avoid returning a mutable of the original
        return tuple(self._tags)

    def tags_by_board(self, board):
        """ The tags assigned to a particular board for this vertex

        :return: A tuple of related tags
        :rtype: tuple
        :raise None: Raises no known exceptions
        """
        return tuple([tag for tag in self._tags if tag.board_address==board])

    def tags_by_port(self, port):
        """ The tags relating to a particular port for this vertex

        :return: A tuple of related tags
        :rtype: tuple
        :raise None: Raises no known exceptions
        """
        return tuple([tag for tag in self._tags if tag.port==port])

    def tags_by_tag(self, tag_id):
        """ The tags with the same tag number for this vertex

        :return: A tuple of related tags
        :rtype: tuple
        :raise None: Raises no known exceptions
        """
        return tuple([tag for tag in self._tags if tag.tag==tag_id])

    def tags_by_host(self, host):
        """ The tags related to the IP address indicated for host on this vertex

        :return: A tuple of related tags
        :rtype: tuple
        :raise None: Raises no known exceptions
        """
        return tuple([tag for tag in self._tags if tag.ip_address==host])

    def tags_by_type(self, tag_type):
        """ The tags of a particular type associated with this vertex

        :return: A tuple of the given tag type
        :rtype: tuple
        :raise None: Raises no known exceptions
        """
        return tuple([tag for tag in self._tags if isinstance(tag, tag_type)])

    def add_tag(self, tag):
        self._tags.append(tag)
        self._add_tag_constraint(tag)


